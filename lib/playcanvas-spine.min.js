/* Copyright 2015-2016 PlayCanvas Ltd */

var spine = {
    radDeg: 180 / Math.PI,
    degRad: Math.PI / 180,
    Float32Array: Array,
    Uint32Array: Array,
    Uint16Array: Array
};

spine.temp = new spine.Float32Array(2), spine.BoneData = function(t, e) {
    this.name = t, this.parent = e;
}, spine.BoneData.prototype = {
    length: 0,
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    inheritScale: !0,
    inheritRotation: !0
}, spine.BlendMode = {
    normal: 0,
    additive: 1,
    multiply: 2,
    screen: 3
}, spine.SlotData = function(t, e) {
    this.name = t, this.boneData = e;
}, spine.SlotData.prototype = {
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    attachmentName: null,
    blendMode: spine.BlendMode.normal
}, spine.IkConstraintData = function(t) {
    this.name = t, this.bones = [];
}, spine.IkConstraintData.prototype = {
    target: null,
    bendDirection: 1,
    mix: 1
}, spine.TransformConstraintData = function(t) {
    this.name = t;
}, spine.TransformConstraintData.prototype = {
    bone: null,
    target: null,
    translateMix: 1,
    x: 0,
    y: 0
}, spine.Bone = function(t, e, n) {
    this.data = t, this.skeleton = e, this.parent = n, this.setToSetupPose();
}, spine.Bone.yDown = !1, spine.Bone.prototype = {
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    a: 0,
    b: 0,
    worldX: 0,
    c: 0,
    d: 0,
    worldY: 0,
    worldSignX: 1,
    worldSignY: 1,
    update: function() {
        this.updateWorldTransform(this.x, this.y, this.rotation, this.scaleX, this.scaleY);
    },
    updateWorldTransformWith: function() {
        this.updateWorldTransform(this.x, this.y, this.rotation, this.scaleX, this.scaleY);
    },
    updateWorldTransform: function(t, e, n, i, s) {
        this.appliedRotation = n, this.appliedScaleX = i, this.appliedScaleY = s, n *= spine.degRad;
        var a = Math.cos(n), r = Math.sin(n), o = a * i, h = -r * s, l = r * i, p = a * s, f = this.parent;
        if (!f) {
            var u = this.skeleton;
            return u.flipX && (t = -t, o = -o, h = -h), u.flipY != spine.Bone.yDown && (e = -e, 
            l = -l, p = -p), this.a = o, this.b = h, this.c = l, this.d = p, this.worldX = t, 
            this.worldY = e, this.worldSignX = i < 0 ? -1 : 1, void (this.worldSignY = s < 0 ? -1 : 1);
        }
        var d = f.a, c = f.b, m = f.c, g = f.d;
        if (this.worldX = d * t + c * e + f.worldX, this.worldY = m * t + g * e + f.worldY, 
        this.worldSignX = f.worldSignX * (i < 0 ? -1 : 1), this.worldSignY = f.worldSignY * (s < 0 ? -1 : 1), 
        this.data.inheritRotation && this.data.inheritScale) this.a = d * o + c * l, this.b = d * h + c * p, 
        this.c = m * o + g * l, this.d = m * h + g * p; else {
            if (this.data.inheritRotation) {
                m = c = 0, g = d = 1;
                do {
                    n = f.appliedRotation * spine.degRad;
                    var v = d * (a = Math.cos(n)) + c * (r = Math.sin(n));
                    if (c = d * -r + c * a, d = v, v = m * a + g * r, g = m * -r + g * a, m = v, !f.data.inheritRotation) break;
                    f = f.parent;
                } while (f);
                this.a = d * o + c * l, this.b = d * h + c * p, this.c = m * o + g * l, this.d = m * h + g * p;
            } else if (this.data.inheritScale) {
                m = c = 0, g = d = 1;
                do {
                    n = f.appliedRotation * spine.degRad, a = Math.cos(n), r = Math.sin(n);
                    var y = f.appliedScaleX, w = f.appliedScaleY, A = a * y, x = -r * w, b = r * y, k = a * w;
                    v = d * A + c * b;
                    if (c = d * x + c * k, d = v, v = m * A + g * b, g = m * x + g * k, m = v, y < 0 && (n = -n), 
                    v = d * (a = Math.cos(-n)) + c * (r = Math.sin(-n)), c = d * -r + c * a, d = v, 
                    v = m * a + g * r, g = m * -r + g * a, m = v, !f.data.inheritScale) break;
                    f = f.parent;
                } while (f);
                this.a = d * o + c * l, this.b = d * h + c * p, this.c = m * o + g * l, this.d = m * h + g * p;
            } else this.a = o, this.b = h, this.c = l, this.d = p;
            this.skeleton.flipX && (this.a = -this.a, this.b = -this.b), this.skeleton.flipY != spine.Bone.yDown && (this.c = -this.c, 
            this.d = -this.d);
        }
    },
    setToSetupPose: function() {
        var t = this.data;
        this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, 
        this.scaleY = t.scaleY;
    },
    getWorldRotationX: function() {
        return Math.atan2(this.c, this.a) * spine.radDeg;
    },
    getWorldRotationY: function() {
        return Math.atan2(this.d, this.b) * spine.radDeg;
    },
    getWorldScaleX: function() {
        return Math.sqrt(this.a * this.a + this.b * this.b) * this.worldSignX;
    },
    getWorldScaleY: function() {
        return Math.sqrt(this.c * this.c + this.d * this.d) * this.worldSignY;
    },
    worldToLocal: function(t) {
        var e = t[0] - this.worldX, n = t[1] - this.worldY, i = this.a, s = this.b, a = this.c, r = this.d, o = 1 / (i * r - s * a);
        return t[0] = e * r * o - n * s * o, t[1] = n * i * o - e * a * o, t;
    },
    localToWorld: function(t) {
        var e = t[0], n = t[1];
        return t[0] = e * this.a + n * this.b + this.worldX, t[1] = e * this.c + n * this.d + this.worldY, 
        t;
    }
}, spine.Slot = function(t, e) {
    this.data = t, this.bone = e, this.attachmentVertices = new spine.Float32Array(), 
    this.setToSetupPose();
}, spine.Slot.prototype = {
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    _attachmentTime: 0,
    attachment: null,
    setAttachment: function(t) {
        this.attachment != t && (this.attachment = t, this._attachmentTime = this.bone.skeleton.time, 
        this.attachmentVertices.length = 0);
    },
    setAttachmentTime: function(t) {
        this._attachmentTime = this.bone.skeleton.time - t;
    },
    getAttachmentTime: function() {
        return this.bone.skeleton.time - this._attachmentTime;
    },
    setToSetupPose: function() {
        var t = this.data;
        if (this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, t.attachmentName) {
            for (var e = this.bone.skeleton.data.slots, n = 0, i = e.length; n < i; n++) if (e[n] == t) {
                this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachmentBySlotIndex(n, t.attachmentName));
                break;
            }
        } else this.setAttachment(null);
    }
}, spine.IkConstraint = function(t, e) {
    this.data = t, this.mix = t.mix, this.bendDirection = t.bendDirection, this.bones = [];
    for (var n = 0, i = t.bones.length; n < i; n++) this.bones[n] = e.findBone(t.bones[n].name);
    this.target = e.findBone(t.target.name);
}, spine.IkConstraint.prototype = {
    apply: function() {
        this.update();
    },
    update: function() {
        var t = this.target, e = this.bones;
        switch (e.length) {
          case 1:
            spine.IkConstraint.apply1(e[0], t.worldX, t.worldY, this.mix);
            break;

          case 2:
            spine.IkConstraint.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.mix);
        }
    }
}, spine.IkConstraint.apply1 = function(t, e, n, i) {
    var s = t.parent ? t.parent.getWorldRotationX() : 0, a = t.rotation, r = Math.atan2(n - t.worldY, e - t.worldX) * spine.radDeg - s;
    t.worldSignX != t.worldSignY != (t.skeleton.flipX != (t.skeleton.flipY != spine.Bone.yDown)) && (r = 360 - r), 
    180 < r ? r -= 360 : r < -180 && (r += 360), t.updateWorldTransform(t.x, t.y, a + (r - a) * i, t.appliedScaleX, t.appliedScaleY);
}, spine.IkConstraint.apply2 = function(t, e, n, i, s, a) {
    if (0 != a) {
        var r, o, h, l = t.x, p = t.y, f = t.appliedScaleX, u = t.appliedScaleY;
        f < 0 ? (f = -f, r = 180, h = -1) : (r = 0, h = 1), u < 0 && (u = -u, h = -h);
        var d = e.x, c = e.y, m = e.appliedScaleX, g = Math.abs(f - u) <= 1e-4;
        g || 0 == c || (e.worldX = t.a * d + t.worldX, e.worldY = t.c * d + t.worldY, c = 0), 
        m < 0 ? (m = -m, o = 180) : o = 0;
        var v, y, w, A, x = t.parent;
        if (x) {
            var b = x.a, k = x.b, S = x.c, C = 1 / (b * (F = x.d) - k * S), T = x.worldX, M = x.worldY;
            v = ((q = n - T) * F - (z = i - M) * k) * C - l, y = (z * b - q * S) * C - p, w = ((q = e.worldX - T) * F - (z = e.worldY - M) * k) * C - l, 
            A = (z * b - q * S) * C - p;
        } else v = n - l, y = i - p, w = e.worldX - l, A = e.worldY - p;
        var I, _, O = Math.sqrt(w * w + A * A), D = e.data.length * m;
        t: if (g) {
            var X = (v * v + y * y - O * O - (D *= f) * D) / (2 * O * D);
            X < -1 ? X = -1 : 1 < X && (X = 1), _ = Math.acos(X) * s;
            b = O + D * X;
            var V = D * Math.sin(_);
            I = Math.atan2(y * b - v * V, v * b + y * V);
        } else {
            b = f * D, k = u * D;
            var F, Y = Math.atan2(y, v), P = b * b, U = k * k, R = v * v + y * y, B = U * (O * O) + P * R - P * U, W = -2 * U * O, E = U - P;
            if (0 <= (F = W * W - 4 * E * B)) {
                var L = Math.sqrt(F);
                W < 0 && (L = -L);
                var N = (L = -(W + L) / 2) / E, H = B / L, j = Math.abs(N) < Math.abs(H) ? N : H;
                if (j * j <= R) {
                    var z = Math.sqrt(R - j * j) * s;
                    I = Y - Math.atan2(z, j), _ = Math.atan2(z / u, (j - O) / f);
                    break t;
                }
            }
            var q, J = 0, G = Number.MAX_VALUE, K = 0, $ = 0, Q = 0, Z = 0, tt = 0, et = 0, nt = (q = O + b) * q;
            Z < nt && (Q = 0, Z = nt, tt = q), (nt = (q = O - b) * q) < G && (J = Math.PI, G = nt, 
            K = q);
            var it = Math.acos(-b * O / (P - U));
            (nt = (q = b * Math.cos(it) + O) * q + (z = k * Math.sin(it)) * z) < G && (J = it, 
            G = nt, K = q, $ = z), Z < nt && (Q = it, Z = nt, tt = q, et = z), R <= (G + Z) / 2 ? (I = Y - Math.atan2($ * s, K), 
            _ = J * s) : (I = Y - Math.atan2(et * s, tt), _ = Q * s);
        }
        var st = Math.atan2(c, d) * h;
        180 < (I = (I - st) * spine.radDeg + r) ? I -= 360 : I < -180 && (I += 360), 180 < (_ = (_ + st) * spine.radDeg * h + o) ? _ -= 360 : _ < -180 && (_ += 360);
        var at = t.rotation;
        t.updateWorldTransform(l, p, at + (I - at) * a, t.appliedScaleX, t.appliedScaleY), 
        at = e.rotation, e.updateWorldTransform(d, c, at + (_ - at) * a, e.appliedScaleX, e.appliedScaleY);
    }
}, spine.TransformConstraint = function(t, e) {
    this.data = t, this.translateMix = t.translateMix, this.x = t.x, this.y = t.y, this.bone = e.findBone(t.bone.name), 
    this.target = e.findBone(t.target.name);
}, spine.TransformConstraint.prototype = {
    apply: function() {
        this.update();
    },
    update: function() {
        var t = this.translateMix;
        if (0 < t) {
            var e = spine.temp;
            e[0] = x, e[1] = y, this.target.localToWorld(e);
            var n = this.bone;
            n.worldX += (e[0] - n.worldX) * t, n.worldY += (e[1] - n.worldY) * t;
        }
    }
}, spine.Skin = function(t) {
    this.name = t, this.attachments = {};
}, spine.Skin.prototype = {
    addAttachment: function(t, e, n) {
        this.attachments[t + ":" + e] = n;
    },
    getAttachment: function(t, e) {
        return this.attachments[t + ":" + e];
    },
    _attachAll: function(t, e) {
        for (var n in e.attachments) {
            var i = n.indexOf(":"), s = parseInt(n.substring(0, i)), a = n.substring(i + 1), r = t.slots[s];
            if (r.attachment && r.attachment.name == a) {
                var o = this.getAttachment(s, a);
                o && r.setAttachment(o);
            }
        }
    }
}, spine.Animation = function(t, e, n) {
    this.name = t, this.timelines = e, this.duration = n;
}, spine.Animation.prototype = {
    apply: function(t, e, n, i, s) {
        i && 0 != this.duration && (n %= this.duration, 0 < e && (e %= this.duration));
        for (var a = this.timelines, r = 0, o = a.length; r < o; r++) a[r].apply(t, e, n, s, 1);
    },
    mix: function(t, e, n, i, s, a) {
        i && 0 != this.duration && (n %= this.duration, 0 < e && (e %= this.duration));
        for (var r = this.timelines, o = 0, h = r.length; o < h; o++) r[o].apply(t, e, n, s, a);
    }
}, spine.Animation.binarySearch = function(t, e, n) {
    var i = 0, s = Math.floor(t.length / n) - 2;
    if (!s) return n;
    for (var a = s >>> 1; ;) {
        if (t[(a + 1) * n] <= e ? i = a + 1 : s = a, i == s) return (i + 1) * n;
        a = i + s >>> 1;
    }
}, spine.Animation.binarySearch1 = function(t, e) {
    var n = 0, i = t.length - 2;
    if (!i) return 1;
    for (var s = i >>> 1; ;) {
        if (t[s + 1] <= e ? n = s + 1 : i = s, n == i) return n + 1;
        s = n + i >>> 1;
    }
}, spine.Animation.linearSearch = function(t, e, n) {
    for (var i = 0, s = t.length - n; i <= s; i += n) if (t[i] > e) return i;
    return -1;
}, spine.Curves = function(t) {
    var e = 19 * (t - 1);
    this.curves = new spine.Float32Array(e), this.curves.length = e;
}, spine.Curves.prototype = {
    setLinear: function(t) {
        this.curves[19 * t] = 0;
    },
    setStepped: function(t) {
        this.curves[19 * t] = 1;
    },
    setCurve: function(t, e, n, i, s) {
        var a = .1 * .1 * .1, r = 6 * a, o = 2 * -e + i, h = 2 * -n + s, l = 3 * (e - i) + 1, p = 3 * (n - s) + 1, f = e * (3 * .1) + o * (.1 * .1 * 3) + l * a, u = n * (3 * .1) + h * (.1 * .1 * 3) + p * a, d = o * (.1 * .1 * 6) + l * r, c = h * (.1 * .1 * 6) + p * r, m = l * r, g = p * r, v = 19 * t, y = this.curves;
        y[v++] = 2;
        for (var w = f, A = u, x = v + 19 - 1; v < x; v += 2) y[v] = w, y[v + 1] = A, f += d, 
        u += c, d += m, c += g, w += f, A += u;
    },
    getCurvePercent: function(t, e) {
        e = e < 0 ? 0 : 1 < e ? 1 : e;
        var n = this.curves, i = 19 * t, s = n[i];
        if (0 === s) return e;
        if (1 == s) return 0;
        for (var a = 0, r = ++i, o = i + 19 - 1; i < o; i += 2) {
            var h, l;
            if (e <= (a = n[i])) return i == r ? l = h = 0 : (h = n[i - 2], l = n[i - 1]), l + (n[i + 1] - l) * (e - h) / (a - h);
        }
        var p = n[i - 1];
        return p + (1 - p) * (e - a) / (1 - a);
    }
}, spine.RotateTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(2 * t), 
    this.frames.length = 2 * t;
}, spine.RotateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 2;
    },
    setFrame: function(t, e, n) {
        t *= 2, this.frames[t] = e, this.frames[t + 1] = n;
    },
    apply: function(t, e, n, i, s) {
        var a = this.frames;
        if (!(n < a[0])) {
            var r = t.bones[this.boneIndex];
            if (n >= a[a.length - 2]) {
                for (var o = r.data.rotation + a[a.length - 1] - r.rotation; 180 < o; ) o -= 360;
                for (;o < -180; ) o += 360;
                r.rotation += o * s;
            } else {
                var h = spine.Animation.binarySearch(a, n, 2), l = a[h - 1], p = a[h], f = 1 - (n - p) / (a[h - 2] - p);
                f = this.curves.getCurvePercent(h / 2 - 1, f);
                for (o = a[h + 1] - l; 180 < o; ) o -= 360;
                for (;o < -180; ) o += 360;
                for (o = r.data.rotation + (l + o * f) - r.rotation; 180 < o; ) o -= 360;
                for (;o < -180; ) o += 360;
                r.rotation += o * s;
            }
        }
    }
}, spine.TranslateTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(3 * t), 
    this.frames.length = 3 * t;
}, spine.TranslateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3;
    },
    setFrame: function(t, e, n, i) {
        t *= 3, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = i;
    },
    apply: function(t, e, n, i, s) {
        var a = this.frames;
        if (!(n < a[0])) {
            var r = t.bones[this.boneIndex];
            if (n >= a[a.length - 3]) return r.x += (r.data.x + a[a.length - 2] - r.x) * s, 
            void (r.y += (r.data.y + a[a.length - 1] - r.y) * s);
            var o = spine.Animation.binarySearch(a, n, 3), h = a[o - 2], l = a[o - 1], p = a[o], f = 1 - (n - p) / (a[o + -3] - p);
            f = this.curves.getCurvePercent(o / 3 - 1, f), r.x += (r.data.x + h + (a[o + 1] - h) * f - r.x) * s, 
            r.y += (r.data.y + l + (a[o + 2] - l) * f - r.y) * s;
        }
    }
}, spine.ScaleTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(3 * t), 
    this.frames.length = 3 * t;
}, spine.ScaleTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3;
    },
    setFrame: function(t, e, n, i) {
        t *= 3, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = i;
    },
    apply: function(t, e, n, i, s) {
        var a = this.frames;
        if (!(n < a[0])) {
            var r = t.bones[this.boneIndex];
            if (n >= a[a.length - 3]) return r.scaleX += (r.data.scaleX * a[a.length - 2] - r.scaleX) * s, 
            void (r.scaleY += (r.data.scaleY * a[a.length - 1] - r.scaleY) * s);
            var o = spine.Animation.binarySearch(a, n, 3), h = a[o - 2], l = a[o - 1], p = a[o], f = 1 - (n - p) / (a[o + -3] - p);
            f = this.curves.getCurvePercent(o / 3 - 1, f), r.scaleX += (r.data.scaleX * (h + (a[o + 1] - h) * f) - r.scaleX) * s, 
            r.scaleY += (r.data.scaleY * (l + (a[o + 2] - l) * f) - r.scaleY) * s;
        }
    }
}, spine.ColorTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(5 * t), 
    this.frames.length = 5 * t;
}, spine.ColorTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 5;
    },
    setFrame: function(t, e, n, i, s, a) {
        t *= 5, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = i, this.frames[t + 3] = s, 
        this.frames[t + 4] = a;
    },
    apply: function(t, e, n, i, s) {
        var a = this.frames;
        if (!(n < a[0])) {
            var r, o, h, l;
            if (n >= a[a.length - 5]) {
                var p = a.length - 1;
                r = a[p - 3], o = a[p - 2], h = a[p - 1], l = a[p];
            } else {
                var f = spine.Animation.binarySearch(a, n, 5), u = a[f - 4], d = a[f - 3], c = a[f - 2], m = a[f - 1], g = a[f], v = 1 - (n - g) / (a[f - 5] - g);
                v = this.curves.getCurvePercent(f / 5 - 1, v), r = u + (a[f + 1] - u) * v, o = d + (a[f + 2] - d) * v, 
                h = c + (a[f + 3] - c) * v, l = m + (a[f + 4] - m) * v;
            }
            var y = t.slots[this.slotIndex];
            s < 1 ? (y.r += (r - y.r) * s, y.g += (o - y.g) * s, y.b += (h - y.b) * s, y.a += (l - y.a) * s) : (y.r = r, 
            y.g = o, y.b = h, y.a = l);
        }
    }
}, spine.AttachmentTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(t), this.frames.length = t, 
    this.attachmentNames = [], this.attachmentNames.length = t;
}, spine.AttachmentTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function() {
        return this.frames.length;
    },
    setFrame: function(t, e, n) {
        this.frames[t] = e, this.attachmentNames[t] = n;
    },
    apply: function(t, e, n, i, s) {
        var a = this.frames;
        if (n < a[0]) n < e && this.apply(t, e, Number.MAX_VALUE, null, 0); else {
            n < e && (e = -1);
            var r = n >= a[a.length - 1] ? a.length - 1 : spine.Animation.binarySearch1(a, n) - 1;
            if (!(a[r] < e)) {
                var o = this.attachmentNames[r];
                t.slots[this.slotIndex].setAttachment(o ? t.getAttachmentBySlotIndex(this.slotIndex, o) : null);
            }
        }
    }
}, spine.EventTimeline = function(t) {
    this.frames = new spine.Float32Array(t), this.frames.length = t, this.events = [], 
    this.events.length = t;
}, spine.EventTimeline.prototype = {
    getFrameCount: function() {
        return this.frames.length;
    },
    setFrame: function(t, e) {
        this.frames[t] = e.time, this.events[t] = e;
    },
    apply: function(t, e, n, i, s) {
        if (i) {
            var a = this.frames, r = a.length;
            if (n < e) this.apply(t, e, Number.MAX_VALUE, i, s), e = -1; else if (e >= a[r - 1]) return;
            if (!(n < a[0])) {
                var o;
                if (e < a[0]) o = 0; else for (var h = a[o = spine.Animation.binarySearch1(a, e)]; 0 < o && a[o - 1] == h; ) o--;
                for (var l = this.events; o < r && n >= a[o]; o++) i[i.length] = l[o];
            }
        }
    }
}, spine.DrawOrderTimeline = function(t) {
    this.frames = new spine.Float32Array(t), this.frames.length = t, this.drawOrders = [], 
    this.drawOrders.length = t;
}, spine.DrawOrderTimeline.prototype = {
    getFrameCount: function() {
        return this.frames.length;
    },
    setFrame: function(t, e, n) {
        this.frames[t] = e, this.drawOrders[t] = n;
    },
    apply: function(t, e, n, i, s) {
        var a = this.frames;
        if (!(n < a[0])) {
            var r;
            r = n >= a[a.length - 1] ? a.length - 1 : spine.Animation.binarySearch1(a, n) - 1;
            var o = t.drawOrder, h = t.slots, l = this.drawOrders[r];
            if (l) for (p = 0, f = l.length; p < f; p++) o[p] = t.slots[l[p]]; else for (var p = 0, f = h.length; p < f; p++) o[p] = h[p];
        }
    }
}, spine.FfdTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(t), this.frames.length = t, 
    this.frameVertices = [], this.frameVertices.length = t;
}, spine.FfdTimeline.prototype = {
    slotIndex: 0,
    attachment: 0,
    getFrameCount: function() {
        return this.frames.length;
    },
    setFrame: function(t, e, n) {
        this.frames[t] = e, this.frameVertices[t] = n;
    },
    apply: function(t, e, n, i, s) {
        var a = t.slots[this.slotIndex], r = a.attachment;
        if (r && (r == this.attachment || r.inheritFFD && r.parentMesh == this.attachment)) {
            var o = this.frames;
            if (!(n < o[0])) {
                var h = this.frameVertices, l = h[0].length, p = a.attachmentVertices;
                if (p.length != l && (a.attachmentVertices = p = new spine.Float32Array(l), s = 1), 
                n >= o[o.length - 1]) {
                    var f = h[o.length - 1];
                    if (s < 1) for (var u = 0; u < l; u++) p[u] += (f[u] - p[u]) * s; else for (u = 0; u < l; u++) p[u] = f[u];
                } else {
                    var d = spine.Animation.binarySearch1(o, n), c = o[d], m = 1 - (n - c) / (o[d - 1] - c);
                    m = this.curves.getCurvePercent(d - 1, m < 0 ? 0 : 1 < m ? 1 : m);
                    var g = h[d - 1], v = h[d];
                    if (s < 1) for (u = 0; u < l; u++) {
                        var y = g[u];
                        p[u] += (y + (v[u] - y) * m - p[u]) * s;
                    } else for (u = 0; u < l; u++) {
                        y = g[u];
                        p[u] = y + (v[u] - y) * m;
                    }
                }
            }
        }
    }
}, spine.IkConstraintTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(3 * t), 
    this.frames.length = 3 * t;
}, spine.IkConstraintTimeline.prototype = {
    ikConstraintIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3;
    },
    setFrame: function(t, e, n, i) {
        t *= 3, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = i;
    },
    apply: function(t, e, n, i, s) {
        var a = this.frames;
        if (!(n < a[0])) {
            var r = t.ikConstraints[this.ikConstraintIndex];
            if (n >= a[a.length - 3]) return r.mix += (a[a.length - 2] - r.mix) * s, void (r.bendDirection = a[a.length - 1]);
            var o = spine.Animation.binarySearch(a, n, 3), h = a[o + -2], l = a[o], p = 1 - (n - l) / (a[o + -3] - l);
            p = this.curves.getCurvePercent(o / 3 - 1, p);
            var f = h + (a[o + 1] - h) * p;
            r.mix += (f - r.mix) * s, r.bendDirection = a[o + -1];
        }
    }
}, spine.SkeletonData = function() {
    this.bones = [], this.slots = [], this.skins = [], this.events = [], this.animations = [], 
    this.ikConstraints = [], this.transformConstraints = [];
}, spine.SkeletonData.prototype = {
    name: null,
    defaultSkin: null,
    width: 0,
    height: 0,
    version: null,
    hash: null,
    findBone: function(t) {
        for (var e = this.bones, n = 0, i = e.length; n < i; n++) if (e[n].name == t) return e[n];
        return null;
    },
    findBoneIndex: function(t) {
        for (var e = this.bones, n = 0, i = e.length; n < i; n++) if (e[n].name == t) return n;
        return -1;
    },
    findSlot: function(t) {
        for (var e = this.slots, n = 0, i = e.length; n < i; n++) if (e[n].name == t) return slot[n];
        return null;
    },
    findSlotIndex: function(t) {
        for (var e = this.slots, n = 0, i = e.length; n < i; n++) if (e[n].name == t) return n;
        return -1;
    },
    findSkin: function(t) {
        for (var e = this.skins, n = 0, i = e.length; n < i; n++) if (e[n].name == t) return e[n];
        return null;
    },
    findEvent: function(t) {
        for (var e = this.events, n = 0, i = e.length; n < i; n++) if (e[n].name == t) return e[n];
        return null;
    },
    findAnimation: function(t) {
        for (var e = this.animations, n = 0, i = e.length; n < i; n++) if (e[n].name == t) return e[n];
        return null;
    },
    findIkConstraint: function(t) {
        for (var e = this.ikConstraints, n = 0, i = e.length; n < i; n++) if (e[n].name == t) return e[n];
        return null;
    },
    findTransformConstraints: function(t) {
        for (var e = this.transformConstraints, n = 0, i = e.length; n < i; n++) if (e[n].name == t) return e[n];
        return null;
    }
}, spine.Skeleton = function(t) {
    this.data = t, this.bones = [];
    for (var e = 0, n = t.bones.length; e < n; e++) {
        var i = t.bones[e], s = i.parent ? this.bones[t.bones.indexOf(i.parent)] : null;
        this.bones[e] = new spine.Bone(i, this, s);
    }
    this.slots = [], this.drawOrder = [];
    for (e = 0, n = t.slots.length; e < n; e++) {
        var a = t.slots[e], r = this.bones[t.bones.indexOf(a.boneData)], o = new spine.Slot(a, r);
        this.slots[e] = o, this.drawOrder[e] = o;
    }
    this.ikConstraints = [];
    for (e = 0, n = t.ikConstraints.length; e < n; e++) this.ikConstraints[e] = new spine.IkConstraint(t.ikConstraints[e], this);
    this.transformConstraints = [];
    for (e = 0, n = t.transformConstraints.length; e < n; e++) this.transformConstraints[e] = new spine.TransformConstraint(t.transformConstraints[e], this);
    this.cache = [], this.updateCache();
}, spine.Skeleton.prototype = {
    x: 0,
    y: 0,
    skin: null,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    time: 0,
    flipX: !1,
    flipY: !1,
    updateCache: function() {
        for (var t = this.bones, e = this.cache, n = this.ikConstraints, i = this.transformConstraints, s = n.length, a = i.length, r = e.length = 0, o = t.length; r < o; r++) {
            var h = t[r];
            e[e.length] = h;
            for (var l = 0; l < s; l++) {
                var p = n[l];
                if (h == p.bones[p.bones.length - 1]) {
                    e[e.length] = p;
                    break;
                }
            }
        }
        for (r = 0; r < a; r++) {
            var f = i[r];
            for (l = e.length - 1; 0 <= l; l--) {
                var u = e[l];
                if (u == f.bone || u == f.target) {
                    e.splice(l + 1, 0, f);
                    break;
                }
            }
        }
    },
    updateWorldTransform: function() {
        for (var t = this.cache, e = 0, n = t.length; e < n; e++) t[e].update();
    },
    setToSetupPose: function() {
        this.setBonesToSetupPose(), this.setSlotsToSetupPose();
    },
    setBonesToSetupPose: function() {
        for (var t = this.bones, e = 0, n = t.length; e < n; e++) t[e].setToSetupPose();
        var i = this.ikConstraints;
        for (e = 0, n = i.length; e < n; e++) {
            (a = i[e]).bendDirection = a.data.bendDirection, a.mix = a.data.mix;
        }
        var s = this.transformConstraints;
        for (e = 0, n = s.length; e < n; e++) {
            var a;
            (a = s[e]).translateMix = a.data.translateMix, a.x = a.data.x, a.y = a.data.y;
        }
    },
    setSlotsToSetupPose: function() {
        for (var t = this.slots, e = this.drawOrder, n = 0, i = t.length; n < i; n++) e[n] = t[n], 
        t[n].setToSetupPose(n);
    },
    getRootBone: function() {
        return this.bones.length ? this.bones[0] : null;
    },
    findBone: function(t) {
        for (var e = this.bones, n = 0, i = e.length; n < i; n++) if (e[n].data.name == t) return e[n];
        return null;
    },
    findBoneIndex: function(t) {
        for (var e = this.bones, n = 0, i = e.length; n < i; n++) if (e[n].data.name == t) return n;
        return -1;
    },
    findSlot: function(t) {
        for (var e = this.slots, n = 0, i = e.length; n < i; n++) if (e[n].data.name == t) return e[n];
        return null;
    },
    findSlotIndex: function(t) {
        for (var e = this.slots, n = 0, i = e.length; n < i; n++) if (e[n].data.name == t) return n;
        return -1;
    },
    setSkinByName: function(t) {
        var e = this.data.findSkin(t);
        if (!e) throw "Skin not found: " + t;
        this.setSkin(e);
    },
    setSkin: function(t) {
        if (t) if (this.skin) t._attachAll(this, this.skin); else for (var e = this.slots, n = 0, i = e.length; n < i; n++) {
            var s = e[n], a = s.data.attachmentName;
            if (a) {
                var r = t.getAttachment(n, a);
                r && s.setAttachment(r);
            }
        }
        this.skin = t;
    },
    getAttachmentBySlotName: function(t, e) {
        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(t), e);
    },
    getAttachmentBySlotIndex: function(t, e) {
        if (this.skin) {
            var n = this.skin.getAttachment(t, e);
            if (n) return n;
        }
        return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null;
    },
    setAttachment: function(t, e) {
        for (var n = this.slots, i = 0, s = n.length; i < s; i++) {
            var a = n[i];
            if (a.data.name == t) {
                var r = null;
                if (e && !(r = this.getAttachmentBySlotIndex(i, e))) throw "Attachment not found: " + e + ", for slot: " + t;
                return void a.setAttachment(r);
            }
        }
        throw "Slot not found: " + t;
    },
    findIkConstraint: function(t) {
        for (var e = this.ikConstraints, n = 0, i = e.length; n < i; n++) if (e[n].data.name == t) return e[n];
        return null;
    },
    findTransformConstraint: function(t) {
        for (var e = this.transformConstraints, n = 0, i = e.length; n < i; n++) if (e[n].data.name == t) return e[n];
        return null;
    },
    update: function(t) {
        this.time += t;
    }
}, spine.EventData = function(t) {
    this.name = t;
}, spine.EventData.prototype = {
    intValue: 0,
    floatValue: 0,
    stringValue: null
}, spine.Event = function(t, e) {
    this.time = t, this.data = e;
}, spine.Event.prototype = {
    intValue: 0,
    floatValue: 0,
    stringValue: null
}, spine.AttachmentType = {
    region: 0,
    boundingbox: 1,
    mesh: 2,
    weightedmesh: 3,
    linkedmesh: 4,
    weightedlinkedmesh: 5
}, spine.RegionAttachment = function(t) {
    this.name = t, this.offset = new spine.Float32Array(8), this.offset.length = 8, 
    this.uvs = new spine.Float32Array(8), this.uvs.length = 8;
}, spine.RegionAttachment.prototype = {
    type: spine.AttachmentType.region,
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    width: 0,
    height: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    rendererObject: null,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    setUVs: function(t, e, n, i, s) {
        var a = this.uvs;
        s ? (a[2] = t, a[3] = i, a[4] = t, a[5] = e, a[6] = n, a[7] = e, a[0] = n, a[1] = i) : (a[0] = t, 
        a[1] = i, a[2] = t, a[3] = e, a[4] = n, a[5] = e, a[6] = n, a[7] = i);
    },
    updateOffset: function() {
        var t = this.width / this.regionOriginalWidth * this.scaleX, e = this.height / this.regionOriginalHeight * this.scaleY, n = -this.width / 2 * this.scaleX + this.regionOffsetX * t, i = -this.height / 2 * this.scaleY + this.regionOffsetY * e, s = n + this.regionWidth * t, a = i + this.regionHeight * e, r = this.rotation * spine.degRad, o = Math.cos(r), h = Math.sin(r), l = n * o + this.x, p = n * h, f = i * o + this.y, u = i * h, d = s * o + this.x, c = s * h, m = a * o + this.y, g = a * h, v = this.offset;
        v[0] = l - u, v[1] = f + p, v[2] = l - g, v[3] = m + p, v[4] = d - g, v[5] = m + c, 
        v[6] = d - u, v[7] = f + c;
    },
    computeVertices: function(t, e, n, i) {
        t += n.worldX, e += n.worldY;
        var s = n.a, a = n.b, r = n.c, o = n.d, h = this.offset;
        i[0] = h[0] * s + h[1] * a + t, i[1] = h[0] * r + h[1] * o + e, i[2] = h[2] * s + h[3] * a + t, 
        i[3] = h[2] * r + h[3] * o + e, i[4] = h[4] * s + h[5] * a + t, i[5] = h[4] * r + h[5] * o + e, 
        i[6] = h[6] * s + h[7] * a + t, i[7] = h[6] * r + h[7] * o + e;
    }
}, spine.MeshAttachment = function(t) {
    this.name = t;
}, spine.MeshAttachment.prototype = {
    type: spine.AttachmentType.mesh,
    vertices: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    inheritFFD: !0,
    parentMesh: null,
    rendererObject: null,
    regionU: 0,
    regionV: 0,
    regionU2: 0,
    regionV2: 0,
    regionRotate: !1,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    edges: null,
    width: 0,
    height: 0,
    updateUVs: function() {
        var t = this.regionU2 - this.regionU, e = this.regionV2 - this.regionV, n = this.regionUVs.length;
        if (this.uvs && this.uvs.length == n || (this.uvs = new spine.Float32Array(n)), 
        this.regionRotate) for (var i = 0; i < n; i += 2) this.uvs[i] = this.regionU + this.regionUVs[i + 1] * t, 
        this.uvs[i + 1] = this.regionV + e - this.regionUVs[i] * e; else for (i = 0; i < n; i += 2) this.uvs[i] = this.regionU + this.regionUVs[i] * t, 
        this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * e;
    },
    computeWorldVertices: function(t, e, n, i) {
        var s = n.bone;
        t += s.worldX, e += s.worldY;
        var a = s.a, r = s.b, o = s.c, h = s.d, l = this.vertices, p = l.length;
        n.attachmentVertices.length == p && (l = n.attachmentVertices);
        for (var f = 0; f < p; f += 2) {
            var u = l[f], d = l[f + 1];
            i[f] = u * a + d * r + t, i[f + 1] = u * o + d * h + e;
        }
    },
    setParentMesh: function(t) {
        (this.parentMesh = t) && (this.vertices = t.vertices, this.regionUVs = t.regionUVs, 
        this.triangles = t.triangles, this.hullLength = t.hullLength, this.edges = t.edges, 
        this.width = t.width, this.height = t.height);
    }
}, spine.WeightedMeshAttachment = function(t) {
    this.name = t;
}, spine.WeightedMeshAttachment.prototype = {
    type: spine.AttachmentType.weightedmesh,
    bones: null,
    weights: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    inheritFFD: !0,
    parentMesh: null,
    rendererObject: null,
    regionU: 0,
    regionV: 0,
    regionU2: 0,
    regionV2: 0,
    regionRotate: !1,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    edges: null,
    width: 0,
    height: 0,
    updateUVs: function(t, e, n, i, s) {
        var a = this.regionU2 - this.regionU, r = this.regionV2 - this.regionV, o = this.regionUVs.length;
        if (this.uvs && this.uvs.length == o || (this.uvs = new spine.Float32Array(o)), 
        this.regionRotate) for (var h = 0; h < o; h += 2) this.uvs[h] = this.regionU + this.regionUVs[h + 1] * a, 
        this.uvs[h + 1] = this.regionV + r - this.regionUVs[h] * r; else for (h = 0; h < o; h += 2) this.uvs[h] = this.regionU + this.regionUVs[h] * a, 
        this.uvs[h + 1] = this.regionV + this.regionUVs[h + 1] * r;
    },
    computeWorldVertices: function(t, e, n, i) {
        var s, a, r, o, h, l, p, f = n.bone.skeleton.bones, u = this.weights, d = this.bones, c = 0, m = 0, g = 0, v = 0, y = d.length;
        if (n.attachmentVertices.length) for (var w = n.attachmentVertices; m < y; c += 2) {
            for (r = a = 0, s = d[m++] + m; m < s; m++, g += 3, v += 2) o = f[d[m]], h = u[g] + w[v], 
            l = u[g + 1] + w[v + 1], p = u[g + 2], a += (h * o.a + l * o.b + o.worldX) * p, 
            r += (h * o.c + l * o.d + o.worldY) * p;
            i[c] = a + t, i[c + 1] = r + e;
        } else for (;m < y; c += 2) {
            for (r = a = 0, s = d[m++] + m; m < s; m++, g += 3) o = f[d[m]], h = u[g], l = u[g + 1], 
            p = u[g + 2], a += (h * o.a + l * o.b + o.worldX) * p, r += (h * o.c + l * o.d + o.worldY) * p;
            i[c] = a + t, i[c + 1] = r + e;
        }
    },
    setParentMesh: function(t) {
        (this.parentMesh = t) && (this.bones = t.bones, this.weights = t.weights, this.regionUVs = t.regionUVs, 
        this.triangles = t.triangles, this.hullLength = t.hullLength, this.edges = t.edges, 
        this.width = t.width, this.height = t.height);
    }
}, spine.BoundingBoxAttachment = function(t) {
    this.name = t, this.vertices = new spine.Float32Array();
}, spine.BoundingBoxAttachment.prototype = {
    type: spine.AttachmentType.boundingbox,
    computeWorldVertices: function(t, e, n, i) {
        t += n.worldX, e += n.worldY;
        for (var s = n.a, a = n.b, r = n.c, o = n.d, h = this.vertices, l = 0, p = h.length; l < p; l += 2) {
            var f = h[l], u = h[l + 1];
            i[l] = f * s + u * a + t, i[l + 1] = f * r + u * o + e;
        }
    }
}, spine.AnimationStateData = function(t) {
    this.skeletonData = t, this.animationToMixTime = {};
}, spine.AnimationStateData.prototype = {
    defaultMix: 0,
    setMixByName: function(t, e, n) {
        var i = this.skeletonData.findAnimation(t);
        if (!i) throw "Animation not found: " + t;
        var s = this.skeletonData.findAnimation(e);
        if (!s) throw "Animation not found: " + e;
        this.setMix(i, s, n);
    },
    setMix: function(t, e, n) {
        this.animationToMixTime[t.name + ":" + e.name] = n;
    },
    getMix: function(t, e) {
        var n = t.name + ":" + e.name;
        return this.animationToMixTime.hasOwnProperty(n) ? this.animationToMixTime[n] : this.defaultMix;
    }
}, spine.TrackEntry = function() {}, spine.TrackEntry.prototype = {
    next: null,
    previous: null,
    animation: null,
    loop: !1,
    delay: 0,
    time: 0,
    lastTime: -1,
    endTime: 0,
    timeScale: 1,
    mixTime: 0,
    mixDuration: 0,
    mix: 1,
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null
}, spine.AnimationState = function(t) {
    this.data = t, this.tracks = [], this.events = [];
}, spine.AnimationState.prototype = {
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null,
    timeScale: 1,
    update: function(t) {
        t *= this.timeScale;
        for (var e = 0; e < this.tracks.length; e++) {
            var n = this.tracks[e];
            if (n) {
                if (n.time += t * n.timeScale, n.previous) {
                    var i = t * n.previous.timeScale;
                    n.previous.time += i, n.mixTime += i;
                }
                var s = n.next;
                s ? (s.time = n.lastTime - s.delay, 0 <= s.time && this.setCurrent(e, s)) : !n.loop && n.lastTime >= n.endTime && this.clearTrack(e);
            }
        }
    },
    apply: function(t) {
        for (var e = 0; e < this.tracks.length; e++) {
            var n = this.tracks[e];
            if (n) {
                this.events.length = 0;
                var i = n.time, s = n.lastTime, a = n.endTime, r = n.loop;
                !r && a < i && (i = a);
                var o = n.previous;
                if (o) {
                    var h = o.time;
                    !o.loop && h > o.endTime && (h = o.endTime), o.animation.apply(t, h, h, o.loop, null);
                    var l = n.mixTime / n.mixDuration * n.mix;
                    1 <= l && (l = 1, n.previous = null), n.animation.mix(t, n.lastTime, i, r, this.events, l);
                } else 1 == n.mix ? n.animation.apply(t, n.lastTime, i, r, this.events) : n.animation.mix(t, n.lastTime, i, r, this.events, n.mix);
                for (var p = 0, f = this.events.length; p < f; p++) {
                    var u = this.events[p];
                    n.onEvent && n.onEvent(e, u), this.onEvent && this.onEvent(e, u);
                }
                if (r ? i % a < s % a : s < a && a <= i) {
                    var d = Math.floor(i / a);
                    n.onComplete && n.onComplete(e, d), this.onComplete && this.onComplete(e, d);
                }
                n.lastTime = n.time;
            }
        }
    },
    clearTracks: function() {
        for (var t = 0, e = this.tracks.length; t < e; t++) this.clearTrack(t);
        this.tracks.length = 0;
    },
    clearTrack: function(t) {
        if (!(t >= this.tracks.length)) {
            var e = this.tracks[t];
            e && (e.onEnd && e.onEnd(t), this.onEnd && this.onEnd(t), this.tracks[t] = null);
        }
    },
    _expandToIndex: function(t) {
        if (t < this.tracks.length) return this.tracks[t];
        for (;t >= this.tracks.length; ) this.tracks[this.tracks.length] = null;
        return null;
    },
    setCurrent: function(t, e) {
        var n = this._expandToIndex(t);
        if (n) {
            var i = n.previous;
            n.previous = null, n.onEnd && n.onEnd(t), this.onEnd && this.onEnd(t), e.mixDuration = this.data.getMix(n.animation, e.animation), 
            0 < e.mixDuration && (e.mixTime = 0, i && n.mixTime / n.mixDuration < .5 ? e.previous = i : e.previous = n);
        }
        (this.tracks[t] = e).onStart && e.onStart(t), this.onStart && this.onStart(t);
    },
    setAnimationByName: function(t, e, n) {
        var i = this.data.skeletonData.findAnimation(e);
        if (!i) throw "Animation not found: " + e;
        return this.setAnimation(t, i, n);
    },
    setAnimation: function(t, e, n) {
        var i = new spine.TrackEntry();
        return i.animation = e, i.loop = n, i.endTime = e.duration, this.setCurrent(t, i), 
        i;
    },
    addAnimationByName: function(t, e, n, i) {
        var s = this.data.skeletonData.findAnimation(e);
        if (!s) throw "Animation not found: " + e;
        return this.addAnimation(t, s, n, i);
    },
    addAnimation: function(t, e, n, i) {
        var s = new spine.TrackEntry();
        s.animation = e, s.loop = n, s.endTime = e.duration;
        var a = this._expandToIndex(t);
        if (a) {
            for (;a.next; ) a = a.next;
            a.next = s;
        } else this.tracks[t] = s;
        return i <= 0 && (a ? i += a.endTime - this.data.getMix(a.animation, e) : i = 0), 
        s.delay = i, s;
    },
    getCurrent: function(t) {
        return t >= this.tracks.length ? null : this.tracks[t];
    }
}, spine.SkeletonJson = function(t) {
    this.attachmentLoader = t, this.linkedMeshes = [];
}, spine.SkeletonJson.prototype = {
    scale: 1,
    readSkeletonData: function(t, e) {
        var n = new spine.SkeletonData();
        n.name = e;
        var i = t.skeleton;
        i && (n.hash = i.hash, n.version = i.spine, n.width = i.width || 0, n.height = i.height || 0);
        for (var s = 0, a = (l = t.bones).length; s < a; s++) {
            var r = l[s], o = null;
            if (r.parent && !(o = n.findBone(r.parent))) throw "Parent bone not found: " + r.parent;
            (w = new spine.BoneData(r.name, o)).length = (r.length || 0) * this.scale, w.x = (r.x || 0) * this.scale, 
            w.y = (r.y || 0) * this.scale, w.rotation = r.rotation || 0, w.scaleX = r.hasOwnProperty("scaleX") ? r.scaleX : 1, 
            w.scaleY = r.hasOwnProperty("scaleY") ? r.scaleY : 1, w.inheritScale = !r.hasOwnProperty("inheritScale") || r.inheritScale, 
            w.inheritRotation = !r.hasOwnProperty("inheritRotation") || r.inheritRotation, n.bones[s] = w;
        }
        var h = t.ik;
        if (h) for (s = 0, a = h.length; s < a; s++) {
            for (var l, p = h[s], f = new spine.IkConstraintData(p.name), u = 0, d = (l = p.bones).length; u < d; u++) {
                var c = n.findBone(l[u]);
                if (!c) throw "IK bone not found: " + l[u];
                f.bones[u] = c;
            }
            if (f.target = n.findBone(p.target), !f.target) throw "Target bone not found: " + p.target;
            f.bendDirection = !p.hasOwnProperty("bendPositive") || p.bendPositive ? 1 : -1, 
            f.mix = p.hasOwnProperty("mix") ? p.mix : 1, n.ikConstraints[s] = f;
        }
        var m = t.transform;
        if (m) for (s = 0, a = m.length; s < a; s++) {
            var g = m[s], v = new spine.TransformConstraintData(g.name);
            if (v.bone = n.findBone(g.bone), !v.bone) throw "Bone not found: " + g.bone;
            if (v.target = n.findBone(g.target), !v.target) throw "Target bone not found: " + g.target;
            v.mix = g.hasOwnProperty("translateMix") ? p.translateMix : 1, v.x = (g.x || 0) * this.scale, 
            v.y = (g.y || 0) * this.scale, n.transformConstraints[s] = v;
        }
        var y = t.slots;
        for (s = 0, a = y.length; s < a; s++) {
            var w, A = y[s];
            if (!(w = n.findBone(A.bone))) throw "Slot bone not found: " + A.bone;
            var x = new spine.SlotData(A.name, w), b = A.color;
            b && (x.r = this.toColor(b, 0), x.g = this.toColor(b, 1), x.b = this.toColor(b, 2), 
            x.a = this.toColor(b, 3)), x.attachmentName = A.attachment, x.blendMode = spine.BlendMode[A.blend || "normal"], 
            n.slots[s] = x;
        }
        var k = t.skins;
        for (var S in k) if (k.hasOwnProperty(S)) {
            var C = k[S], T = new spine.Skin(S);
            for (var M in C) if (C.hasOwnProperty(M)) {
                var I = n.findSlotIndex(M), _ = C[M];
                for (var O in _) if (_.hasOwnProperty(O)) {
                    var D = this.readAttachment(T, I, O, _[O]);
                    D && T.addAttachment(I, O, D);
                }
            }
            "default" == (n.skins[n.skins.length] = T).name && (n.defaultSkin = T);
        }
        for (s = 0, a = this.linkedMeshes.length; s < a; s++) {
            var X = this.linkedMeshes[s];
            if (!(T = X.skin ? n.findSkin(X.skin) : n.defaultSkin)) throw "Skin not found: " + X.skin;
            if (!(o = T.getAttachment(X.slotIndex, X.parent))) throw "Parent mesh not found: " + X.parent;
            X.mesh.setParentMesh(o), X.mesh.updateUVs();
        }
        this.linkedMeshes.length = 0;
        var V = t.events;
        for (var F in V) if (V.hasOwnProperty(F)) {
            var Y = V[F], P = new spine.EventData(F);
            P.intValue = Y.int || 0, P.floatValue = Y.float || 0, P.stringValue = Y.string || null, 
            n.events[n.events.length] = P;
        }
        var U = t.animations;
        for (var R in U) U.hasOwnProperty(R) && this.readAnimation(R, U[R], n);
        return n;
    },
    readAttachment: function(t, e, n, i) {
        n = i.name || n;
        var s = i.type || "region";
        "skinnedmesh" == s && (s = "weightedmesh"), s = spine.AttachmentType[s];
        var a = i.path || n, r = this.scale;
        switch (s) {
          case spine.AttachmentType.region:
            var o = this.attachmentLoader.newRegionAttachment(t, n, a);
            if (!o) return null;
            o.path = a, o.x = (i.x || 0) * r, o.y = (i.y || 0) * r, o.scaleX = i.hasOwnProperty("scaleX") ? i.scaleX : 1, 
            o.scaleY = i.hasOwnProperty("scaleY") ? i.scaleY : 1, o.rotation = i.rotation || 0, 
            o.width = (i.width || 0) * r, o.height = (i.height || 0) * r;
            var h = i.color;
            return h && (o.r = this.toColor(h, 0), o.g = this.toColor(h, 1), o.b = this.toColor(h, 2), 
            o.a = this.toColor(h, 3)), o.updateOffset(), o;

          case spine.AttachmentType.mesh:
          case spine.AttachmentType.linkedmesh:
            return (l = this.attachmentLoader.newMeshAttachment(t, n, a)) ? (l.path = a, (h = i.color) && (l.r = this.toColor(h, 0), 
            l.g = this.toColor(h, 1), l.b = this.toColor(h, 2), l.a = this.toColor(h, 3)), l.width = (i.width || 0) * r, 
            l.height = (i.height || 0) * r, i.parent ? (l.inheritFFD = !i.hasOwnProperty("ffd") || i.ffd, 
            this.linkedMeshes[this.linkedMeshes.length] = {
                mesh: l,
                skin: i.skin,
                slotIndex: e,
                parent: i.parent
            }) : (l.vertices = this.getFloatArray(i, "vertices", r), l.triangles = this.getUint32Array(i, "triangles"), 
            l.regionUVs = this.getFloatArray(i, "uvs", 1), l.updateUVs(), l.hullLength = 2 * (i.hull || 0), 
            i.edges && (l.edges = this.getUint16Array(i, "edges"))), l) : null;

          case spine.AttachmentType.weightedmesh:
          case spine.AttachmentType.weightedlinkedmesh:
            var l;
            if (!(l = this.attachmentLoader.newWeightedMeshAttachment(t, n, a))) return null;
            if (l.path = a, (h = i.color) && (l.r = this.toColor(h, 0), l.g = this.toColor(h, 1), 
            l.b = this.toColor(h, 2), l.a = this.toColor(h, 3)), l.width = (i.width || 0) * r, 
            l.height = (i.height || 0) * r, i.parent) l.inheritFFD = !i.hasOwnProperty("ffd") || i.ffd, 
            this.linkedMeshes[this.linkedMeshes.length] = {
                mesh: l,
                skin: i.skin,
                slotIndex: e,
                parent: i.parent
            }; else {
                for (var p = this.getFloatArray(i, "uvs", 1), f = this.getFloatArray(i, "vertices", 1), u = new spine.Float32Array(3 * p.length * 3), d = new spine.Uint32Array(3 * p.length), c = 0, m = 0, g = 0, v = f.length; c < v; ) for (var y = 0 | f[c++], w = c + 4 * (d[m++] = y); c < w; ) d[m++] = f[c], 
                u[g++] = f[c + 1] * r, u[g++] = f[c + 2] * r, u[g++] = f[c + 3], c += 4;
                l.bones = d, l.weights = u, l.triangles = this.getUint32Array(i, "triangles"), l.regionUVs = p, 
                l.updateUVs(), l.hullLength = 2 * (i.hull || 0), i.edges && (l.edges = this.getUint16Array(i, "edges"));
            }
            return l;

          case spine.AttachmentType.boundingbox:
            var A = this.attachmentLoader.newBoundingBoxAttachment(t, n);
            for (c = 0, v = (f = i.vertices).length; c < v; c++) A.vertices[c] = f[c] * r;
            return A;
        }
        throw "Unknown attachment type: " + s;
    },
    readAnimation: function(t, e, n) {
        var i = [], s = 0, a = e.slots;
        for (var r in a) if (a.hasOwnProperty(r)) {
            var o = a[r], h = n.findSlotIndex(r);
            for (var l in o) if (o.hasOwnProperty(l)) {
                var p = o[l];
                if ("color" == l) {
                    (U = new spine.ColorTimeline(p.length)).slotIndex = h;
                    for (var f = 0, u = 0, d = p.length; u < d; u++) {
                        var c = (w = p[u]).color, m = this.toColor(c, 0), g = this.toColor(c, 1), v = this.toColor(c, 2), y = this.toColor(c, 3);
                        U.setFrame(f, w.time, m, g, v, y), this.readCurve(U, f, w), f++;
                    }
                    i[i.length] = U, s = Math.max(s, U.frames[5 * U.getFrameCount() - 5]);
                } else {
                    if ("attachment" != l) throw "Invalid timeline type for a slot: " + l + " (" + r + ")";
                    (U = new spine.AttachmentTimeline(p.length)).slotIndex = h;
                    for (f = 0, u = 0, d = p.length; u < d; u++) {
                        var w = p[u];
                        U.setFrame(f++, w.time, w.name);
                    }
                    i[i.length] = U, s = Math.max(s, U.frames[U.getFrameCount() - 1]);
                }
            }
        }
        var A = e.bones;
        for (var x in A) if (A.hasOwnProperty(x)) {
            var b = n.findBoneIndex(x);
            if (-1 == b) throw "Bone not found: " + x;
            var k = A[x];
            for (var l in k) if (k.hasOwnProperty(l)) {
                p = k[l];
                if ("rotate" == l) {
                    (U = new spine.RotateTimeline(p.length)).boneIndex = b;
                    for (f = 0, u = 0, d = p.length; u < d; u++) {
                        w = p[u];
                        U.setFrame(f, w.time, w.angle), this.readCurve(U, f, w), f++;
                    }
                    i[i.length] = U, s = Math.max(s, U.frames[2 * U.getFrameCount() - 2]);
                } else {
                    if ("translate" != l && "scale" != l) throw "Invalid timeline type for a bone: " + l + " (" + x + ")";
                    var S = 1;
                    "scale" == l ? U = new spine.ScaleTimeline(p.length) : (U = new spine.TranslateTimeline(p.length), 
                    S = this.scale), U.boneIndex = b;
                    for (f = 0, u = 0, d = p.length; u < d; u++) {
                        var C = ((w = p[u]).x || 0) * S, T = (w.y || 0) * S;
                        U.setFrame(f, w.time, C, T), this.readCurve(U, f, w), f++;
                    }
                    i[i.length] = U, s = Math.max(s, U.frames[3 * U.getFrameCount() - 3]);
                }
            }
        }
        var M = e.ik;
        for (var I in M) if (M.hasOwnProperty(I)) {
            var _ = n.findIkConstraint(I);
            p = M[I];
            (U = new spine.IkConstraintTimeline(p.length)).ikConstraintIndex = n.ikConstraints.indexOf(_);
            for (f = 0, u = 0, d = p.length; u < d; u++) {
                var O = (w = p[u]).hasOwnProperty("mix") ? w.mix : 1, D = !w.hasOwnProperty("bendPositive") || w.bendPositive ? 1 : -1;
                U.setFrame(f, w.time, O, D), this.readCurve(U, f, w), f++;
            }
            i[i.length] = U, s = Math.max(s, U.frames[3 * U.getFrameCount() - 3]);
        }
        var X = e.ffd;
        for (var V in X) {
            var F = n.findSkin(V);
            o = X[V];
            for (r in o) {
                h = n.findSlotIndex(r);
                var Y = o[r];
                for (var P in Y) {
                    p = Y[P];
                    var U = new spine.FfdTimeline(p.length), R = F.getAttachment(h, P);
                    if (!R) throw "FFD attachment not found: " + P;
                    U.slotIndex = h;
                    var B, W = (U.attachment = R).type == spine.AttachmentType.mesh;
                    B = W ? R.vertices.length : R.weights.length / 3 * 2;
                    for (f = 0, u = 0, d = p.length; u < d; u++) {
                        if ((w = p[u]).vertices) {
                            var E, L = w.vertices;
                            (E = new spine.Float32Array(B)).length = B;
                            var N = w.offset || 0, H = L.length;
                            if (1 == this.scale) for (var j = 0; j < H; j++) E[j + N] = L[j]; else for (j = 0; j < H; j++) E[j + N] = L[j] * this.scale;
                            if (W) {
                                var z = R.vertices;
                                for (j = 0, H = E.length; j < H; j++) E[j] += z[j];
                            }
                        } else W ? E = R.vertices : (E = new spine.Float32Array(B)).length = B;
                        U.setFrame(f, w.time, E), this.readCurve(U, f, w), f++;
                    }
                    i[i.length] = U, s = Math.max(s, U.frames[U.getFrameCount() - 1]);
                }
            }
        }
        var q = e.drawOrder;
        if (q || (q = e.draworder), q) {
            U = new spine.DrawOrderTimeline(q.length);
            var J = n.slots.length;
            for (f = 0, u = 0, d = q.length; u < d; u++) {
                var G = q[u], K = null;
                if (G.offsets) {
                    for (j = ((K = new spine.Uint32Array(J)).length = J) - 1; 0 <= j; j--) K[j] = 4294967295;
                    var $ = G.offsets, Q = new spine.Uint32Array(J - $.length);
                    Q.length = J - $.length;
                    var Z = 0, tt = 0;
                    for (j = 0, H = $.length; j < H; j++) {
                        var et = $[j];
                        if (-1 == (h = n.findSlotIndex(et.slot))) throw "Slot not found: " + et.slot;
                        for (;Z != h; ) Q[tt++] = Z++;
                        K[Z + et.offset] = Z++;
                    }
                    for (;Z < J; ) Q[tt++] = Z++;
                    for (j = J - 1; 0 <= j; j--) 4294967295 == K[j] && (K[j] = Q[--tt]);
                }
                U.setFrame(f++, G.time, K);
            }
            i[i.length] = U, s = Math.max(s, U.frames[U.getFrameCount() - 1]);
        }
        var nt = e.events;
        if (nt) {
            for (U = new spine.EventTimeline(nt.length), f = 0, u = 0, d = nt.length; u < d; u++) {
                var it = nt[u], st = n.findEvent(it.name);
                if (!st) throw "Event not found: " + it.name;
                var at = new spine.Event(it.time, st);
                at.intValue = it.hasOwnProperty("int") ? it.int : st.intValue, at.floatValue = it.hasOwnProperty("float") ? it.float : st.floatValue, 
                at.stringValue = it.hasOwnProperty("string") ? it.string : st.stringValue, U.setFrame(f++, at);
            }
            i[i.length] = U, s = Math.max(s, U.frames[U.getFrameCount() - 1]);
        }
        n.animations[n.animations.length] = new spine.Animation(t, i, s);
    },
    readCurve: function(t, e, n) {
        var i = n.curve;
        i ? "stepped" == i ? t.curves.setStepped(e) : i instanceof Array && t.curves.setCurve(e, i[0], i[1], i[2], i[3]) : t.curves.setLinear(e);
    },
    toColor: function(t, e) {
        if (8 != t.length) throw "Color hexidecimal length must be 8, recieved: " + t;
        return parseInt(t.substring(2 * e, 2 * e + 2), 16) / 255;
    },
    getFloatArray: function(t, e, n) {
        var i = t[e], s = new spine.Float32Array(i.length), a = 0, r = i.length;
        if (1 == n) for (;a < r; a++) s[a] = i[a]; else for (;a < r; a++) s[a] = i[a] * n;
        return s;
    },
    getUint32Array: function(t, e) {
        for (var n = t[e], i = new spine.Uint32Array(n.length), s = 0, a = n.length; s < a; s++) i[s] = 0 | n[s];
        return i;
    },
    getUint16Array: function(t, e) {
        for (var n = t[e], i = new spine.Uint16Array(n.length), s = 0, a = n.length; s < a; s++) i[s] = 0 | n[s];
        return i;
    }
}, spine.Atlas = function(t, e) {
    this.textureLoader = e, this.pages = [], this.regions = [];
    var n = new spine.AtlasReader(t), i = [];
    i.length = 4;
    for (var s = null; ;) {
        var a = n.readLine();
        if (null === a) break;
        if ((a = n.trim(a)).length) if (s) {
            var r = new spine.AtlasRegion();
            r.name = a, r.page = s, r.rotate = "true" == n.readValue(), n.readTuple(i);
            var o = parseInt(i[0]), h = parseInt(i[1]);
            n.readTuple(i);
            var l = parseInt(i[0]), p = parseInt(i[1]);
            r.u = o / s.width, r.v = h / s.height, r.rotate ? (r.u2 = (o + p) / s.width, r.v2 = (h + l) / s.height) : (r.u2 = (o + l) / s.width, 
            r.v2 = (h + p) / s.height), r.x = o, r.y = h, r.width = Math.abs(l), r.height = Math.abs(p), 
            4 == n.readTuple(i) && (r.splits = [ parseInt(i[0]), parseInt(i[1]), parseInt(i[2]), parseInt(i[3]) ], 
            4 == n.readTuple(i) && (r.pads = [ parseInt(i[0]), parseInt(i[1]), parseInt(i[2]), parseInt(i[3]) ], 
            n.readTuple(i))), r.originalWidth = parseInt(i[0]), r.originalHeight = parseInt(i[1]), 
            n.readTuple(i), r.offsetX = parseInt(i[0]), r.offsetY = parseInt(i[1]), r.index = parseInt(n.readValue()), 
            this.regions[this.regions.length] = r;
        } else {
            (s = new spine.AtlasPage()).name = a, 2 == n.readTuple(i) && (s.width = parseInt(i[0]), 
            s.height = parseInt(i[1]), n.readTuple(i)), s.format = spine.Atlas.Format[i[0]], 
            n.readTuple(i), s.minFilter = spine.Atlas.TextureFilter[i[0]], s.magFilter = spine.Atlas.TextureFilter[i[1]];
            var f = n.readValue();
            s.uWrap = spine.Atlas.TextureWrap.clampToEdge, s.vWrap = spine.Atlas.TextureWrap.clampToEdge, 
            "x" == f ? s.uWrap = spine.Atlas.TextureWrap.repeat : "y" == f ? s.vWrap = spine.Atlas.TextureWrap.repeat : "xy" == f && (s.uWrap = s.vWrap = spine.Atlas.TextureWrap.repeat), 
            e.load(s, a, this), this.pages[this.pages.length] = s;
        } else s = null;
    }
}, spine.Atlas.prototype = {
    findRegion: function(t) {
        for (var e = this.regions, n = 0, i = e.length; n < i; n++) if (e[n].name == t) return e[n];
        return null;
    },
    dispose: function() {
        for (var t = this.pages, e = 0, n = t.length; e < n; e++) this.textureLoader.unload(t[e].rendererObject);
    },
    updateUVs: function(t) {
        for (var e = this.regions, n = 0, i = e.length; n < i; n++) {
            var s = e[n];
            s.page == t && (s.u = s.x / t.width, s.v = s.y / t.height, s.rotate ? (s.u2 = (s.x + s.height) / t.width, 
            s.v2 = (s.y + s.width) / t.height) : (s.u2 = (s.x + s.width) / t.width, s.v2 = (s.y + s.height) / t.height));
        }
    }
}, spine.Atlas.Format = {
    alpha: 0,
    intensity: 1,
    luminanceAlpha: 2,
    rgb565: 3,
    rgba4444: 4,
    rgb888: 5,
    rgba8888: 6
}, spine.Atlas.TextureFilter = {
    nearest: 0,
    linear: 1,
    mipMap: 2,
    mipMapNearestNearest: 3,
    mipMapLinearNearest: 4,
    mipMapNearestLinear: 5,
    mipMapLinearLinear: 6
}, spine.Atlas.TextureWrap = {
    mirroredRepeat: 0,
    clampToEdge: 1,
    repeat: 2
}, spine.AtlasPage = function() {}, spine.AtlasPage.prototype = {
    name: null,
    format: null,
    minFilter: null,
    magFilter: null,
    uWrap: null,
    vWrap: null,
    rendererObject: null,
    width: 0,
    height: 0
}, spine.AtlasRegion = function() {}, spine.AtlasRegion.prototype = {
    page: null,
    name: null,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    u: 0,
    v: 0,
    u2: 0,
    v2: 0,
    offsetX: 0,
    offsetY: 0,
    originalWidth: 0,
    originalHeight: 0,
    index: 0,
    rotate: !1,
    splits: null,
    pads: null
}, spine.AtlasReader = function(t) {
    this.lines = t.split(/\r\n|\r|\n/);
}, spine.AtlasReader.prototype = {
    index: 0,
    trim: function(t) {
        return t.replace(/^\s+|\s+$/g, "");
    },
    readLine: function() {
        return this.index >= this.lines.length ? null : this.lines[this.index++];
    },
    readValue: function() {
        var t = this.readLine(), e = t.indexOf(":");
        if (-1 == e) throw "Invalid line: " + t;
        return this.trim(t.substring(e + 1));
    },
    readTuple: function(t) {
        var e = this.readLine(), n = e.indexOf(":");
        if (-1 == n) throw "Invalid line: " + e;
        for (var i = 0, s = n + 1; i < 3; i++) {
            var a = e.indexOf(",", s);
            if (-1 == a) break;
            t[i] = this.trim(e.substr(s, a - s)), s = a + 1;
        }
        return t[i] = this.trim(e.substring(s)), i + 1;
    }
}, spine.AtlasAttachmentLoader = function(t) {
    this.atlas = t;
}, spine.AtlasAttachmentLoader.prototype = {
    newRegionAttachment: function(t, e, n) {
        var i = this.atlas.findRegion(n);
        if (!i) throw "Region not found in atlas: " + n + " (region attachment: " + e + ")";
        var s = new spine.RegionAttachment(e);
        return s.rendererObject = i, s.setUVs(i.u, i.v, i.u2, i.v2, i.rotate), s.regionOffsetX = i.offsetX, 
        s.regionOffsetY = i.offsetY, s.regionWidth = i.width, s.regionHeight = i.height, 
        s.regionOriginalWidth = i.originalWidth, s.regionOriginalHeight = i.originalHeight, 
        s;
    },
    newMeshAttachment: function(t, e, n) {
        var i = this.atlas.findRegion(n);
        if (!i) throw "Region not found in atlas: " + n + " (mesh attachment: " + e + ")";
        var s = new spine.MeshAttachment(e);
        return s.rendererObject = i, s.regionU = i.u, s.regionV = i.v, s.regionU2 = i.u2, 
        s.regionV2 = i.v2, s.regionRotate = i.rotate, s.regionOffsetX = i.offsetX, s.regionOffsetY = i.offsetY, 
        s.regionWidth = i.width, s.regionHeight = i.height, s.regionOriginalWidth = i.originalWidth, 
        s.regionOriginalHeight = i.originalHeight, s;
    },
    newWeightedMeshAttachment: function(t, e, n) {
        var i = this.atlas.findRegion(n);
        if (!i) throw "Region not found in atlas: " + n + " (weighted mesh attachment: " + e + ")";
        var s = new spine.WeightedMeshAttachment(e);
        return s.rendererObject = i, s.regionU = i.u, s.regionV = i.v, s.regionU2 = i.u2, 
        s.regionV2 = i.v2, s.regionRotate = i.rotate, s.regionOffsetX = i.offsetX, s.regionOffsetY = i.offsetY, 
        s.regionWidth = i.width, s.regionHeight = i.height, s.regionOriginalWidth = i.originalWidth, 
        s.regionOriginalHeight = i.originalHeight, s;
    },
    newBoundingBoxAttachment: function(t, e) {
        return new spine.BoundingBoxAttachment(e);
    }
}, spine.SkeletonBounds = function() {
    this.polygonPool = [], this.polygons = [], this.boundingBoxes = [];
}, spine.SkeletonBounds.prototype = {
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0,
    update: function(t, e) {
        for (var n = t.slots, i = n.length, s = t.x, a = t.y, r = this.boundingBoxes, o = this.polygonPool, h = this.polygons, l = r.length = 0, p = h.length; l < p; l++) o[o.length] = h[l];
        for (l = h.length = 0; l < i; l++) {
            var f = n[l], u = f.attachment;
            if (u.type == spine.AttachmentType.boundingbox) {
                r[r.length] = u;
                var d, c = o.length;
                0 < c ? (d = o[c - 1], o.splice(c - 1, 1)) : d = new spine.Float32Array(), (h[h.length] = d).length = u.vertices.length, 
                u.computeWorldVertices(s, a, f.bone, d);
            }
        }
        e && this.aabbCompute();
    },
    aabbCompute: function() {
        for (var t = this.polygons, e = Number.MAX_VALUE, n = Number.MAX_VALUE, i = -Number.MAX_VALUE, s = -Number.MAX_VALUE, a = 0, r = t.length; a < r; a++) for (var o = t[a], h = 0, l = o.length; h < l; h += 2) {
            var p = o[h], f = o[h + 1];
            e = Math.min(e, p), n = Math.min(n, f), i = Math.max(i, p), s = Math.max(s, f);
        }
        this.minX = e, this.minY = n, this.maxX = i, this.maxY = s;
    },
    aabbContainsPoint: function(t, e) {
        return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY;
    },
    aabbIntersectsSegment: function(t, e, n, i) {
        var s = this.minX, a = this.minY, r = this.maxX, o = this.maxY;
        if (t <= s && n <= s || e <= a && i <= a || r <= t && r <= n || o <= e && o <= i) return !1;
        var h = (i - e) / (n - t), l = h * (s - t) + e;
        if (a < l && l < o) return !0;
        if (a < (l = h * (r - t) + e) && l < o) return !0;
        var p = (a - e) / h + t;
        return s < p && p < r || s < (p = (o - e) / h + t) && p < r;
    },
    aabbIntersectsSkeleton: function(t) {
        return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY;
    },
    containsPoint: function(t, e) {
        for (var n = this.polygons, i = 0, s = n.length; i < s; i++) if (this.polygonContainsPoint(n[i], t, e)) return this.boundingBoxes[i];
        return null;
    },
    intersectsSegment: function(t, e, n, i) {
        for (var s = this.polygons, a = 0, r = s.length; a < r; a++) if (s[a].intersectsSegment(t, e, n, i)) return this.boundingBoxes[a];
        return null;
    },
    polygonContainsPoint: function(t, e, n) {
        for (var i = t.length, s = i - 2, a = !1, r = 0; r < i; r += 2) {
            var o = t[r + 1], h = t[s + 1];
            if (o < n && n <= h || h < n && n <= o) {
                var l = t[r];
                l + (n - o) / (h - o) * (t[s] - l) < e && (a = !a);
            }
            s = r;
        }
        return a;
    },
    polygonIntersectsSegment: function(t, e, n, i, s) {
        for (var a = t.length, r = e - i, o = n - s, h = e * s - n * i, l = t[a - 2], p = t[a - 1], f = 0; f < a; f += 2) {
            var u = t[f], d = t[f + 1], c = l * d - p * u, m = l - u, g = p - d, v = r * g - o * m, y = (h * m - r * c) / v;
            if ((l <= y && y <= u || u <= y && y <= l) && (e <= y && y <= i || i <= y && y <= e)) {
                var w = (h * g - o * c) / v;
                if ((p <= w && w <= d || d <= w && w <= p) && (n <= w && w <= s || s <= w && w <= n)) return !0;
            }
            l = u, p = d;
        }
        return !1;
    },
    getPolygon: function(t) {
        var e = this.boundingBoxes.indexOf(t);
        return -1 == e ? null : this.polygons[e];
    },
    getWidth: function() {
        return this.maxX - this.minX;
    },
    getHeight: function() {
        return this.maxY - this.minY;
    }
}, pc.extend(pc, function() {
    var o = function(t) {
        this._textureData = t;
    };
    o.prototype = {
        load: function(t, e, n) {
            var i = this._textureData[e];
            i && (t.rendererObject = i, t.width = i.width, t.height = i.height, n.updateUVs(t));
        },
        unload: function(t) {
            t.destroy();
        }
    };
    var t = function(t, e, n, i) {
        this._app = t, this._position = new pc.Vec3();
        var s = new spine.Atlas(e, new o(i)), a = new spine.SkeletonJson(new spine.AtlasAttachmentLoader(s));
        a.scale *= .01;
        var r = a.readSkeletonData(n);
        this.skeleton = new spine.Skeleton(r), this.skeleton.updateWorldTransform(), this.stateData = new spine.AnimationStateData(this.skeleton.data), 
        this.states = [ new spine.AnimationState(this.stateData) ], this._node = new pc.GraphNode(), 
        this._meshInstances = [], this._materials = {}, this._priority = 0, this._layers = [ pc.LAYERID_WORLD ], 
        this.update(0), this.autoUpdate = !0, this._model = new pc.Model(), this._model.graph = this._node, 
        this._model.meshInstances = this._meshInstances, this._modelChanged = !0, this._reordered = !0, 
        this._hidden = !1;
    };
    return t.prototype = {
        destroy: function() {
            this._model && this._removeFromLayers(), this._model = null, this._meshInstances = [], 
            this.skeleton = null, this.stateData = null, this.state = null, this._materials = {}, 
            this._node = null;
        },
        hide: function() {
            if (!this._hidden) {
                for (var t = this.skeleton.drawOrder, e = 0, n = t.length; e < n; e++) {
                    var i = t[e];
                    i.current && i.current.meshInstance && (i.current.meshInstance.visible = !1);
                }
                this._hidden = !0;
            }
        },
        show: function() {
            if (this._hidden) {
                for (var t = this.skeleton.drawOrder, e = 0, n = t.length; e < n; e++) {
                    var i = t[e];
                    i.current && i.current.meshInstance && (i.current.meshInstance.visible = !0);
                }
                this._hidden = !1;
            }
        },
        updateSlot: function(t, e) {
            var n = e.attachment;
            if (e.current && e.current.meshInstance && (e.current.meshInstance.visible = !1), 
            n) {
                var i = n.name;
                if (void 0 === e.positions && (e.vertices = [], e.positions = []), void 0 === e.meshes && (e.current = {
                    mesh: null,
                    meshInstance: null
                }, e.meshes = {}, e.meshInstances = {}, e.materials = {}), n.computeVertices && n.computeVertices(this.skeleton.x, this.skeleton.y, e.bone, e.vertices), 
                n.computeWorldVertices && n.computeWorldVertices(this.skeleton.x, this.skeleton.y, e, e.vertices), 
                n instanceof spine.RegionAttachment) {
                    if (e.positions = [ e.vertices[0], e.vertices[1], this._position.z, e.vertices[2], e.vertices[3], this._position.z, e.vertices[4], e.vertices[5], this._position.z, e.vertices[6], e.vertices[7], this._position.z ], 
                    void 0 === e.meshes[i]) {
                        var s = {
                            normals: [ 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0 ],
                            uvs: [ n.uvs[0], 1 - n.uvs[1], n.uvs[2], 1 - n.uvs[3], n.uvs[4], 1 - n.uvs[5], n.uvs[6], 1 - n.uvs[7] ],
                            indices: [ 0, 3, 2, 2, 1, 0 ]
                        };
                        e.meshes[i] = pc.createMesh(this._app.graphicsDevice, e.positions, s), e.meshes[i].name = i;
                    }
                } else if (n instanceof spine.WeightedMeshAttachment || n instanceof spine.MeshAttachment) {
                    for (var a = 0, r = [], o = 0, h = e.vertices.length; o < h; o += 2) e.positions[a] = e.vertices[o], 
                    e.positions[a + 1] = e.vertices[o + 1], e.positions[a + 2] = this._position.z, r[a] = 0, 
                    r[a + 1] = 1, r[a + 2] = 0, a += 3;
                    if (void 0 === e.meshes[i]) {
                        s = {
                            normals: r,
                            uvs: n.uvs.map(function(t, e) {
                                return e % 2 ? 1 - t : t;
                            }),
                            indices: n.triangles.reverse()
                        };
                        e.meshes[i] = pc.createMesh(this._app.graphicsDevice, e.positions, s), e.meshes[i].name = i;
                    }
                }
                if (void 0 === e.materials[i]) {
                    var l = n.rendererObject.page.rendererObject;
                    if (l) if (l instanceof pc.StandardMaterial) e.materials[i] = l, this._materials[l.name] = l; else {
                        var p = null;
                        l.getSource() instanceof Image && (p = l.getSource().getAttribute("src")), p && void 0 !== this._materials[p] ? e.materials[i] = this._materials[p] : (e.materials[i] = new pc.StandardMaterial(), 
                        e.materials[i].shadingModel = pc.SPECULAR_BLINN, e.materials[i].diffuse = new pc.Color(0, 0, 0), 
                        e.materials[i].emissiveMap = l, e.materials[i].opacityMap = l, e.materials[i].opacityMapChannel = "a", 
                        e.materials[i].depthWrite = !1, e.materials[i].cull = pc.CULLFACE_NONE, e.materials[i].blendType = pc.BLEND_PREMULTIPLIED, 
                        e.materials[i].update(), e.materials[i].chunks.outputAlphaPremulPS = pc.shaderChunks.outputAlphaPS, 
                        p && (this._materials[p] = e.materials[i]));
                    }
                }
                void 0 === e.meshInstances[i] && (e.meshInstances[i] = new pc.MeshInstance(this._node, e.meshes[i], e.materials[i]), 
                this._meshInstances.push(e.meshInstances[i]), this._modelChanged = !0, this._reordered = !0), 
                e.meshes[i].updateVertices(e.positions), e.current.mesh = e.meshes[i], e.current.meshInstance = e.meshInstances[i], 
                e.current.meshInstance.visible = !0;
            }
        },
        reorder: function() {
            for (var t = this.skeleton.drawOrder, e = 0, n = t.length; e < n; e++) {
                var i = t[e];
                if (i.attachment) {
                    var s = i.attachment.name, a = i.meshInstances[s];
                    a && (a.drawOrder = e + 1e3 * this.priority);
                }
            }
        },
        update: function(t) {
            if (!this._hidden) {
                for (var e = 0, n = this.states.length; e < n; e++) this.states[e].update(t);
                for (e = 0, n = this.states.length; e < n; e++) this.states[e].apply(this.skeleton);
                this.autoUpdate && this.skeleton.updateWorldTransform();
                var i = this.skeleton.drawOrder;
                for (e = 0, n = i.length; e < n; e++) {
                    var s = i[e];
                    this.updateSlot(e, s);
                }
                this._modelChanged && this._model && (this._removeFromLayers(), this._addToLayers(), 
                this._modelChanged = !1), this._reordered && this.reorder(), this._reordered = !1;
            }
        },
        setPosition: function(t) {
            this._position.copy(t);
        },
        _removeFromLayers: function() {
            for (var t = 0; t < this._layers.length; t++) {
                var e = this._layers[t], n = this._app.scene.layers.getLayerById(e);
                n && n.removeMeshInstances(this._model.meshInstances);
            }
        },
        _addToLayers: function() {
            for (var t = 0; t < this._layers.length; t++) {
                var e = this._layers[t], n = this._app.scene.layers.getLayerById(e);
                n && n.addMeshInstances(this._model.meshInstances);
            }
        }
    }, Object.defineProperty(t.prototype, "state", {
        get: function() {
            return this.states[0];
        }
    }), Object.defineProperty(t.prototype, "priority", {
        get: function() {
            return this._priority;
        },
        set: function(t) {
            this._priority = t, this._reordered = !0;
        }
    }), Object.defineProperty(t.prototype, "layers", {
        get: function() {
            return this._layers;
        },
        set: function(t) {
            this._model && this._removeFromLayers(), this._layers = t || [], this._model && this._addToLayers();
        }
    }), {
        Spine: t
    };
}()), pc.extend(pc, function() {
    var i = function(t) {
        this.id = "spine", this.description = "", t.systems.add(this.id, this), this.ComponentType = pc.SpineComponent, 
        this.DataType = pc.SpineComponentData, this.schema = [ "enabled", "atlasAsset", "textureAssets", "skeletonAsset", "atlasData", "textures", "skeletonData", "speed", "spine" ], 
        this.on("remove", this.onRemove, this), pc.ComponentSystem.on("update", this.onUpdate, this);
    };
    return i = pc.inherits(i, pc.ComponentSystem), pc.extend(i.prototype, {
        initializeComponentData: function(t, e, n) {
            n = [ "enabled", "atlasAsset", "textureAssets", "skeletonAsset", "atlasData", "textures", "skeletonData", "spine" ], 
            i._super.initializeComponentData.call(this, t, e, n);
        },
        removeComponent: function(t) {
            var e = t.spine.data;
            e.spine && e.spine.destroy();
        },
        onUpdate: function(t) {
            var e = this.store;
            for (var n in e) if (e.hasOwnProperty(n)) {
                var i = e[n], s = i.data;
                s.enabled && i.entity.enabled && s.spine && (s.spine.setPosition(i.entity.getPosition()), 
                s.spine.update(s.speed * t));
            }
        },
        onRemove: function(t, e) {}
    }), {
        SpineComponentSystem: i
    };
}()), pc.extend(pc, function() {
    var e = function(t, e) {
        this.on("set_atlasAsset", this.onSetAsset, this), this.on("set_textureAssets", this.onSetAssets, this), 
        this.on("set_skeletonAsset", this.onSetAsset, this), this.on("set_atlasData", this.onSetResource, this), 
        this.on("set_textures", this.onSetResource, this), this.on("set_skeletonData", this.onSetResource, this);
    };
    return e = pc.inherits(e, pc.Component), pc.extend(e.prototype, {
        _createSpine: function() {
            this.data.spine && (this.data.spine.destroy(), this.data.spine = null);
            for (var t = {}, e = 0, n = this.textureAssets.length; e < n; e++) {
                var i = this.system.app.assets.get(this.textureAssets[e]), s = pc.path.getBasename(i.file.url), a = s.indexOf("?");
                -1 !== a && (s = s.substring(0, a)), t[s] = i.resource;
            }
            this.data.spine = new pc.Spine(this.system.app, this.atlasData, this.skeletonData, t), 
            this.state = this.data.spine.state, this.states = this.data.spine.states, this.skeleton = this.data.spine.skeleton, 
            this.entity.addChild(this.data.spine._node);
        },
        _onAssetReady: function(t) {
            "texture" === t.type && this.textures.push(t.resource), "json" === t.type && (this.skeletonData = t.resource), 
            "text" === t.type && (this.atlasData = t.resource);
        },
        _onAssetAdd: function(t) {
            t.off("change", this.onAssetChanged, this), t.on("change", this.onAssetChanged, this), 
            t.off("remove", this.onAssetRemoved, this), t.on("remove", this.onAssetRemoved, this), 
            t.ready(this._onAssetReady, this), this.system.app.assets.load(t);
        },
        onSetResource: function() {
            this.data.atlasData && this.data.textures.length && this.data.skeletonData && this._createSpine();
        },
        onSetAsset: function(t, e, n) {
            var i = this.system.app.assets, s = null;
            if (e && (s = i.get(e)) && (s.off("change", this.onAssetChanged), s.off("remove", this.onAssetRemoved)), 
            n) {
                var a = n;
                n instanceof pc.Asset && (a = n.id, this.data[t] = a), (s = i.get(a)) ? this._onAssetAdd(s) : i.on("add:" + a);
            }
        },
        onSetAssets: function(t, e, n) {
            var i, s, a = this.system.app.assets, r = null;
            if (e.length) for (i = 0, s = e.length; i < s; i++) (r = a.get(e[i])) && (r.off("change", this.onAssetChanged), 
            r.off("remove", this.onAssetRemoved));
            if (n && n.length) {
                var o = n.map(function(t) {
                    return t instanceof pc.Asset ? t.id : t;
                });
                for (i = 0, s = n.length; i < s; i++) (r = a.get(o[i])) ? this._onAssetAdd(r) : a.on("add:" + o[i]);
            }
        },
        onAssetChanged: function(t, e, n, i) {},
        onAssetRemoved: function(t) {},
        onEnable: function() {
            e._super.onEnable.call(this);
            var t = this.data.spine;
            t && t._model && this.system.app.scene.addModel(t._model);
        },
        onDisable: function() {
            e._super.onDisable.call(this);
            var t = this.data.spine;
            t && t._model && this.system.app.scene.removeModel(t._model);
        },
        hide: function() {
            this.data.spine && this.data.spine.hide();
        },
        show: function() {
            this.data.spine && this.data.spine.show();
        }
    }), {
        SpineComponent: e
    };
}()), pc.extend(pc, function() {
    var t = function() {
        this.enabled = !0, this.atlasAsset = null, this.textureAssets = [], this.skeletonAsset = null, 
        this.speed = 1, this.spine = null, this.atlasData = null, this.textures = [], this.skeletonData = null;
    };
    return {
        SpineComponentData: t = pc.inherits(t, pc.ComponentData)
    };
}()), function() {
    if (pc.Mesh.prototype.updateVertices = function(t, e, n, i) {
        for (var s = t.length / 3, a = new pc.VertexIterator(this.vertexBuffer), r = 0; r < s; r++) a.element[pc.SEMANTIC_POSITION].set(t[3 * r], t[3 * r + 1], t[3 * r + 2]), 
        e && a.element[pc.SEMANTIC_NORMAL].set(e[3 * r], e[3 * r + 1], e[3 * r + 2]), n && a.element[pc.SEMANTIC_TANGENT].set(n[4 * r], n[4 * r + 1], n[4 * r + 2], n[4 * r + 3]), 
        i && a.element[pc.SEMANTIC_TEXCOORD0].set(i[2 * r], i[2 * r + 1]), a.next();
        a.end();
    }, pc.Application.registerPlugin) {
        pc.Application.registerPlugin("spine", function(t) {
            new pc.SpineComponentSystem(t);
        });
    } else {
        var t = pc.Application.getApplication();
        new pc.SpineComponentSystem(t);
    }
}();